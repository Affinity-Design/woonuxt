How Nitro Caching Works for Your Product PagesYour Nuxt 3 application, when deployed to Cloudflare Pages with the Nitro server engine, leverages a powerful caching strategy, especially when combined with Cloudflare KV. Here's the flow for your product pages (e.g., /product/[slug].vue):1. Key Configurations:pages/product/[slug].vue using useAsyncData:You're using await useAsyncData(cacheKey, async () => { ... GqlGetProduct({ slug }) ... }, { server: true, ... }).server: true (which is the default for useAsyncData) means this data fetching logic runs on the server when a page is first requested.The unique cacheKey (e.g., product-your-product-slug) is important for useAsyncData to manage its data.nuxt.config.ts - Nitro Storage:nitro: {
storage: {
cache: { // This is a named storage mount point
driver: "cloudflare-kv-binding",
binding: "NUXT_CACHE", // Your KV namespace for general caching
},
script_data: { // For your build script outputs
driver: "cloudflare-kv-binding",
binding: "NUXT_SCRIPT_DATA",
},
},
// ... devStorage ...
}
This tells Nitro that any storage operations directed to the cache: mount point should use Cloudflare KV via the NUXT_CACHE binding.nuxt.config.ts - Route Rules (Example for Products & Categories):routeRules: {
"/product/**": {
cache: {
maxAge: 60 _ 60 _ 72, // Cache product routes for 72 hours
base: "cache", // Use the 'cache' storage mount point (Cloudflare KV)
},
},
"/product-category/**": { // Crucial for your category pages
cache: {
maxAge: 60 _ 60 _ 24 \* 7, // Cache category routes for 7 days
base: "cache", // Use the 'cache' storage mount point
},
},
// ... other rules
}
This is the crucial part for route-level caching. It instructs Nitro to cache the responses for any product or category page, using the cache storage mount (which is your Cloudflare KV). This is a form of Incremental Static Regeneration (ISR) or server-side caching.2. The Caching Flow (User-Initiated):This describes what happens when a regular user visits a page that hasn't been pre-warmed or whose cache has expired.First Visitor to /product-category/example-category (or any visitor after cache expiry):Request Hits Cloudflare Edge/Nuxt Server.Nitro Checks Route Cache (KV Store): Nitro consults the routeRules. For /product-category/example-category, it checks the NUXT_CACHE KV store for an existing entry.Cache Miss: No valid cache entry found.Server-Side Rendering & Data Fetching:The category page component (e.g., pages/product-category/[slug].vue) renders on the server.Its useAsyncData (or similar data fetching logic) executes, calling your GraphQL API. This is the expensive, potentially 17-second operation you mentioned.Page Rendered & Data Stored in Payload.Nitro Caches the Route in KV: Due to the routeRules, Nitro stores the rendered HTML (or data variant) for /product-category/example-category in the NUXT_CACHE KV store.Response to User: The server-rendered page is sent.Subsequent Visitor to /product-category/example-category (within cache maxAge):Request Hits Server.Nitro Checks KV: Finds the cached entry.Serve from KV Cache: The page is served instantly from KV. The expensive GraphQL call is skipped for this user.Background Revalidation (ISR): Nitro revalidates the page in the background by re-running the data fetching. If data changed, the KV cache is updated for future requests.3. Role of getCachedData in useAsyncData:(As described previously, mainly for client-side navigations and SSG data.)4. Understanding Observed Cache Behavior (Desktop vs. Mobile):(As described previously, related to browser cache, CDN edge cache, etc.)5. The Role of cache-warmer.js in Populating the KV Route Cache (Pre-Warming)This is where your cache warmer scripts become essential for proactively filling the Nitro KV route cache, especially for those expensive category pages.Purpose of cache-warmer.js:The primary goal of your cache-warmer.js script is to simulate user visits to a list of important URLs (like all your product and category pages) before most users do.By "visiting" these pages, it forces Nitro to go through the "First Visitor" flow described in section 2 for each page.How cache-warmer.js (As Refactored) Works:Fetches URL Lists:It calls your internal API endpoints (e.g., /api/internal/script-storage/categories-list, /api/internal/script-storage/products-list).These API routes fetch the lists of category and product slugs that your build scripts (build-categories-cache.js, build-products-cache.js) previously populated into the NUXT_SCRIPT_DATA KV store.Constructs URLs: For each category slug, it constructs the full URL (e.g., https://yourdomain.com/product-category/example-category).Makes HTTP GET Requests: The warmCacheUrl() function within cache-warmer.js makes an actual HTTP GET request to each of these constructed URLs.Effect of the Warmer's GET Requests:Each GET request made by the warmer to a category page URL is treated by Nitro like a request from a regular user.If the page isn't in the NUXT_CACHE KV store (or is stale):Nitro triggers server-side rendering for that category page.The expensive data fetching (GqlGet...) for that category runs.Crucially, Nitro then stores the generated page in the NUXT_CACHE KV store because of your routeRules for /product-category/**.If the page is already in the NUXT_CACHE KV store and is fresh:Nitro would serve it quickly to the warmer (though the warmer doesn't really "use" the response body). The main benefit here is that this "visit" can refresh the cache's recency or potentially trigger ISR's background revalidation if the maxAge is configured for that.Result of Pre-Warming:After cache-warmer.js has run (e.g., via your post-deploy.js script or a scheduled task), a significant portion of your category pages (and product pages) will have their rendered output already stored in the NUXT_CACHE KV namespace.When a real user then visits one of these pre-warmed category pages: Nitro will find the entry in KV (Cache Hit!) and serve it immediately, bypassing the initial 17-second (or however long) data fetch for that user.Ensuring Effective Pre-Warming for Category Pages:Correct routeRules: Your routeRules for /product-category/** are correctly configured with a maxAge and base: "cache", which is essential.Comprehensive Category List: The build-categories-cache.js script must fetch all relevant category slugs that you want to pre-warm and store them in the NUXT_SCRIPT_DATA KV (which cache-warmer.js then reads).Successful cache-warmer.js Execution: The cache-warmer.js script must run successfully after deployment or periodically. It needs the correct FRONTEND_URL (to construct valid URLs to warm) and REVALIDATION_SECRET (to access the API for category/product lists).Sufficient maxAge: The maxAge in your routeRules (e.g., 7 days for categories) should be long enough to make the pre-warming effort worthwhile, but not so long that content becomes overly stale if ISR background updates fail or are infrequent.By running cache-warmer.js, you are proactively triggering the expensive rendering and data-fetching for your category pages, causing their output to be stored in the Cloudflare KV NUXT_CACHE. This ensures that when subsequent users visit these pages, they are served quickly from KV, as intended. The behavior you're seeing (slow on mobile after desktop) might still involve other layers (browser/CDN edge), but the cache warmer's job is to ensure the Nitro KV store itself is populated.Troubleshooting Tips (Reiteration from previous document):(These remain relevant for diagnosing general caching behavior)Check Response Headers (Cache-Control, CF-Cache-Status, X-Nitro-Cache if available).Check for Vary headers.Ensure no unique query parameters are affecting cache keys if ignoreQuery is not used.
